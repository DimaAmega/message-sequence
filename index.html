<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .class-rect {
        border: 1px;
        fill: white;
        stroke-width: 1px;
        stroke: black;
    }

    .class-label {
        font-size: x-small;
        font-weight: bold;
    }

    .message-rect {
        border: 1px;
        fill: green;
        stroke-width: 1px;
        stroke: black;
    }

    div.tooltip {
        position: absolute;
        text-align: left!important;
        padding: 6px;
        font: 13px sans-serif;
        background: lightsteelblue;
        border: 0;
        border-radius: 8px;
    }

    div.tooltip-info {
        text-align: center!important;
    }

    pre.tooltip-message {
        text-align: left!important;
    }

</style>
<body>
<script src="https://d3js.org/d3.v5.min.js"></script>
<svg id="chart1" width="960" height="600"></svg>

<script>
    console.log(d3.version)

    const MESSAGE_LABEL_X_OFFSET = -40;
    // const MESSAGE_LABEL_Y_OFFSET = 75;
    const MESSAGE_ARROW_Y_OFFSET = 80;

    const VERT_SPACE = 170;
    // const VERT_PAD = 20;

    const X_PAD = 100;
    const Y_PAD = 30;

    const MESSAGE_SPACE = 30;

    const DEFAULT_STROKE_WIDTH = "1px";
    const SELECTED_STROKE_WIDTH = "2px";

    const CLASS_WIDTH = VERT_SPACE - 10;
    // const CLASS_LABEL_X_OFFSET = -30;
    // const CLASS_LABEL_Y_OFFSET = 25;

    /**
     * @param {Object[]} data
     * @param {string} data.sender
     * @param {string} data.receiver
     * @param {string} data.label
     * @param {string} data.tooltipMessage
     * @param {string} data.traceId
     * @param {number} data.startTs
     * @param {number} data.endTs
     */
    function processData(data) {
        const senders = d3.set(data.map(d => d.sender)).values();
        const receivers = d3.set(data.map(d => d.receiver)).values();
        const classes = [...new Set([...senders, ...receivers])];
        console.log(classes);

        const svg = d3.select('svg#chart1'),
            margin = {top: 20, right: 50, bottom: 100, left: 80},
            width = VERT_SPACE * classes.length - margin.left - margin.right;
        // width = +svg.attr('width') - margin.left - margin.right,
        // height = +svg.attr('height') - margin.top - margin.bottom,
        const defs = svg.append("svg:defs")

        const g = svg.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        // Graph title
        g.append('text')
            .attr('x', (width / 2))
            .attr('y', 0 - (margin.top / 3))
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('Sequence diagram');

        // Prepare data
        const logicalTimestamps = compressTimestamps(data);
        data.forEach(d => {
            d.logicalStart = logicalTimestamps.get(d.startTs);
            d.logicalEnd = logicalTimestamps.get(d.endTs);
            if (d.traceId === undefined) {
                d.traceId = "";
            }
            d.tooltipMessage = escapeHtml(d.tooltipMessage)
                .replace(/\r\n|\r|\n/g, '<br>');
        });

        const maxTs = data.reduce((currentMax, value) =>
            (currentMax.endTs > value.endTs) ? currentMax : value
        ).endTs

        console.log(maxTs + 100);
        // svg.attr("height", Y_PAD + maxTs + 200);
        svg.attr("height", MESSAGE_ARROW_Y_OFFSET + (logicalTimestamps.size) * MESSAGE_SPACE);
        svg.attr("width", X_PAD + VERT_SPACE * classes.length)

        // Draw vertical lines
        classes.forEach((c, i) => {
            svg.append("line")
                .style("stroke", "#888")
                .attr("x1", X_PAD + i * VERT_SPACE)
                .attr("y1", Y_PAD)
                .attr("x2", X_PAD + i * VERT_SPACE)
                .attr("y2", MESSAGE_ARROW_Y_OFFSET + maxTs + 40);
        });

        // Draw classes
        classes.forEach((c, i) => {
            const x = X_PAD + i * VERT_SPACE;
            const g = svg.append("g")
                .attr("transform", "translate(" + x + "," + Y_PAD + ")")
                .attr("class", "class-rect");
            g.append("rect")
                .attr("x", -CLASS_WIDTH / 2)
                .attr("y", 0)
                .attr("width", CLASS_WIDTH)
                .attr("height", "24px");
        });

        // Draw class labels
        classes.forEach((c, i) => {
            const x = X_PAD + i * VERT_SPACE;
            svg.append("g")
                .attr("transform", "translate(" + x + "," + Y_PAD + ")")
                .append("text")
                .attr("class", "class-label")
                .attr("text-anchor", "middle")
                .text(() => c)
                .attr("dy", "16px");
        });

        // Append div with tooltip
        const tooltipDiv = d3.select("body").append("div");
        const showTooltipClosure = createTooltipClosure(tooltipDiv);

        // Draw message arrows
        const traceIdToColor = assignColorsToTraceId(data)
        const arrowColoredMarker = arrowColoredMarkerClosure(defs)

        data.forEach((m) => {
            const xStart = X_PAD + classes.indexOf(m.sender) * VERT_SPACE
            const xEnd = X_PAD + classes.indexOf(m.receiver) * VERT_SPACE
            // const yStart = MESSAGE_ARROW_Y_OFFSET + m.startTs;
            // const yEnd = MESSAGE_ARROW_Y_OFFSET + m.endTs;
            const yStart = MESSAGE_ARROW_Y_OFFSET + m.logicalStart * MESSAGE_SPACE;
            const yEnd = MESSAGE_ARROW_Y_OFFSET + m.logicalEnd * MESSAGE_SPACE;
            const color = traceIdToColor.get(m.traceId);

            const path = makeLink(svg, m, xStart, yStart, xEnd, yEnd)
                .attr("trace-id", m.traceId)
                .attr("marker-end", arrowColoredMarker(color))
                .style("stroke", color)
                .style("cursor", "pointer")
                .style("stroke-width", DEFAULT_STROKE_WIDTH);
            path.on("click", showTooltipClosure(m, path));

            svg.append("g")
                .attr("transform", "translate(" + xStart + "," + yStart + ")")
                .append("text")
                .attr("dx", "5px")
                .attr("dy", "-2px")
                .attr("text-anchor", "begin")
                .style("font-size", "13px")
                .style("cursor", "pointer")
                .text(() => m.label)
                .on("click", showTooltipClosure(m, path));
        });

        // Draw message timestamps
        const renderedTimestamps = new Set()
        data.forEach((m) => {
            const xPos = X_PAD + MESSAGE_LABEL_X_OFFSET;
            // const yPosStart = MESSAGE_ARROW_Y_OFFSET + m.startTs;
            // const yPosEnd = MESSAGE_ARROW_Y_OFFSET + m.endTs;
            const yPosStart = MESSAGE_ARROW_Y_OFFSET + m.logicalStart * MESSAGE_SPACE;
            const yPosEnd = MESSAGE_ARROW_Y_OFFSET + m.logicalEnd * MESSAGE_SPACE;

            if (!renderedTimestamps.has(yPosStart)) {
                renderedTimestamps.add(yPosStart);
                svg.append("g")
                    .attr("transform", "translate(" + xPos + "," + yPosStart + ")")
                    .attr("class", "first")
                    .attr("text-anchor", "middle")
                    .append("text")
                    .style("font-size", "10px")
                    .text(() => m.startTs);
            }

            if (!renderedTimestamps.has(yPosEnd)) {
                renderedTimestamps.add(yPosEnd);
                svg.append("g")
                    .attr("transform", "translate(" + xPos + "," + yPosEnd + ")")
                    .attr("class", "first")
                    .attr("text-anchor", "middle")
                    .append("text")
                    .style("font-size", "10px")
                    .text(() => m.endTs);
            }
        });
    }

    function makeLink(svg, m, xStart, yStart, xEnd, yEnd) {
        let pathD = m.sender === m.receiver
            ? makeArc(xStart, yStart, xEnd, yEnd, d3.path())
            : makeLine(xStart, yStart, xEnd, yEnd, d3.path());
        return svg.append("path")
            .attr("fill", "none")
            .attr("d", pathD);
    }

    function makeArc(xStart, yStart, xEnd, yEnd, context) {
        const xMid = xStart + VERT_SPACE / 2,
            yMid = (yEnd + yStart) / 2,
            radius = (yEnd - yStart) / 2;
        context.moveTo(xStart, yStart);
        context.arcTo(xMid, yMid, xEnd, yEnd, radius);
        context.lineTo(xEnd, yEnd);
        return context;
    }

    function makeLine(xStart, yStart, xEnd, yEnd, context) {
        context.moveTo(xStart, yStart);
        context.lineTo(xEnd, yEnd);
        return context;
    }

    /**
     *  @param {number} length
     *  @returns {string} random string
     */
    function generateId(length) {
        const arr = new Uint8Array((length || 40) / 2);
        window.crypto.getRandomValues(arr);
        return Array.from(arr, (_) => _.toString(16).padStart(2, "0")).join('');
    }

    /**
     * @param tooltipDiv
     * @return {function(*, *): function(): void}
     */
    function createTooltipClosure(tooltipDiv) {
        tooltipDiv.attr("class", "tooltip")
            .attr("show", false)
            .style("opacity", 0);

        return (message, line) => {
            line.attr("id", "line_" + generateId(20));
            return () => {
                if (tooltipDiv.attr("show") === "true") {
                    const componentId = tooltipDiv.attr("selected-id");
                    tooltipDiv.attr("show", false)
                        .attr("selected-id", null)
                        .style("pointer-events", "none")
                        .transition()
                        .duration(300)
                        .style("opacity", 0)
                        .on("end", () => {
                            tooltipDiv.text("")
                        });
                    d3.select("#" + componentId)
                        .transition()
                        .duration(300)
                        .style("stroke-width", DEFAULT_STROKE_WIDTH);
                } else {
                    tooltipDiv.attr("show", true)
                        .attr("selected-id", line.attr("id"))
                        .style("pointer-events", "auto")
                        .html(
                            "<div class='tooltip-info'>"
                            + "from: " + message.sender
                            + "<br/>to: " + message.receiver
                            + "<br/>started: " + message.startTs
                            + "<br/>finished: " + message.endTs
                            + "<br/>trace-id: " + message.traceId
                            + "<br/>"
                            + "</div>"
                            + "<pre class='tooltip-message'>"
                            + message.tooltipMessage
                            + "</pre>"
                        )
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px")
                        .transition()
                        .duration(200)
                        .style("opacity", 1);
                    line.transition()
                        .duration(200)
                        .style("stroke-width", SELECTED_STROKE_WIDTH)
                }
            }
        }
    }

    /**
     * @param {object[]} data
     * @param {string} data.traceId
     * @return {Map<string, string>} mapping of traceId to Color
     */
    function assignColorsToTraceId(data) {
        const BLACK = '#000000';
        const COLORS = [
            '#e6194B',
            '#3cb44b',
            '#ffe119',
            '#4363d8',
            '#f58231',
            '#911eb4',
            '#42d4f4',
            '#f032e6',
            '#bfef45',
            '#fabed4',
            '#469990',
            '#dcbeff',
            '#9A6324',
            '#fffac8',
            '#800000',
            '#aaffc3',
            '#808000',
            '#ffd8b1',
            '#000075',
        ];

        const uniqueTraceIds = new Set(data.map(_ => _.traceId));
        let traceIdCountWithoutBlack = uniqueTraceIds.has("")
            ? uniqueTraceIds.size - 1
            : uniqueTraceIds.size;

        const traceToColor = new Map();

        if (traceIdCountWithoutBlack <= COLORS.length) {
            let currentColor = 0;
            uniqueTraceIds.forEach(traceId => {
                if (traceId === "") {
                    traceToColor.set(traceId, BLACK);
                } else {
                    traceToColor.set(traceId, COLORS[currentColor]);
                    currentColor++;
                }
            });
        } else {
            // if not enough distinct colors - all stay black
            uniqueTraceIds.forEach(traceId => {
                traceToColor.set(traceId, BLACK);
            });
        }

        return traceToColor;
    }

    /**
     * @return {function(string): string}
     */
    function arrowColoredMarkerClosure(svgDefs) {
        const usedColors = new Set();

        return color => {
            const colorWithoutHash = color.replace("#", "")
            if (!usedColors.has(color)) {
                svgDefs.append("svg:marker")
                    .attr("id", "arrowColoredMarker" + colorWithoutHash)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 10)
                    .attr("refY", 0)
                    .attr("markerWidth", 10)
                    .attr("markerHeight", 10)
                    .attr("orient", "auto")
                    .append("svg:path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .style("fill", color);
                usedColors.add(color);
            }
            return "url(#arrowColoredMarker" + colorWithoutHash + ")";
        }
    }

    /**
     * @param {Object[]} data
     * @param {number} data.startTs
     * @param {number} data.endTs
     */
    function compressTimestamps(data) {
        const starts = data.map(d => d.startTs);
        const ends = data.map(d => d.endTs);
        const realTimestamps = [...new Set([...starts, ...ends])];
        realTimestamps.sort((a, b) => a - b);
        const logicalTimestamps = new Map();
        realTimestamps.forEach((ts, i) => logicalTimestamps.set(ts, i));
        console.log(realTimestamps);
        return logicalTimestamps;
    }

    function escapeHtml(str) {
        return str.replace(
            /[&<>'"]/g,
            tag => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', "'": '&#39;', '"': '&quot;'}[tag] || tag)
        );
    }

    // Get data attach to window
    d3.json("data.json")
        .then(processData);

</script>
